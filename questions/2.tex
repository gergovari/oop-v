\section{Ismertesse a csak C++ nyelvben alkalmazható típuskonverziót, valamint a header fájlok használatánál\\ alkalmazható egyszerűsítést!}

\subsection{C++ specifikus típuskonverziók (Casting)}
A C-stílusú \texttt{(tipus)ertek} konverzió helyett a C++ négy speciális operátort vezetett be. Ezek célja a típusbiztonság növelése és a szándék egyértelmű jelzése a kódban (könnyebb kereshetőség).

\begin{itemize}
    \item \textbf{\texttt{static\_cast<T>(kif)}} -- A "logikus" konverzió
    \begin{itemize}
        \item \textbf{Felhasználás:} Kompatibilis típusok között (pl. \texttt{int} $\to$ \texttt{float}, \texttt{enum} $\to$ \texttt{int}, pointer upcast).
        \item \textbf{Ellenőrzés:} Fordítási időben (Compile-time).
        \item \textbf{Biztonság:} Ha a típusok logikailag nem konvertálhatók, a fordító hibát jelez.
    \end{itemize}

    \item \textbf{\texttt{dynamic\_cast<T>(kif)}} -- Az "objektumorientált" konverzió
    \begin{itemize}
        \item \textbf{Felhasználás:} Polimorf osztályoknál (van \texttt{virtual} függvénye) öröklődési fában lefelé (downcast).
        \item \textbf{Ellenőrzés:} Futási időben (Runtime check).
        \item \textbf{Biztonság:} Ellenőrzi, hogy az objektum ténylegesen az-e, aminek hisszük.
        \begin{itemize}
            \item Pointer esetén: sikertelenségnél \texttt{nullptr}-t ad.
            \item Referencia esetén: sikertelenségnél \texttt{std::bad\_cast} kivételt dob.
        \end{itemize}
    \end{itemize}

    \item \textbf{\texttt{const\_cast<T>(kif)}} -- A "szabálytalanító"
    \begin{itemize}
        \item \textbf{Felhasználás:} A \texttt{const} vagy \texttt{volatile} minősítő levétele.
        \item \textbf{Cél:} Főleg régebbi (legacy) kódok illesztéséhez, ahol egy függvény nem módosít, de lemaradt a paraméteréből a \texttt{const}.
    \end{itemize}

    \item \textbf{\texttt{reinterpret\_cast<T>(kif)}} -- A "brutális" átértelmezés
    \begin{itemize}
        \item \textbf{Felhasználás:} Alacsony szintű bit-manipuláció (pl. pointer konvertálása \texttt{int}-té, vagy két teljesen független pointer típus között).
        \item \textbf{Jellemző:} Nincs ellenőrzés, a biteket változatlanul hagyja, csak másképp értelmezi. Veszélyes és nem hordozható (platformfüggő).
    \end{itemize}
\end{itemize}

\subsection{Header fájlok használatának egyszerűsítése}
A nagy projektek fordítási idejének csökkentése és a körkörös függőségek (circular dependency) elkerüléséhez.

\begin{itemize}
    \item \textbf{Include Guard modernizálása (\texttt{\#pragma once})}
    \begin{itemize}
        \item \textbf{Probléma:} Egy header fájl többszörös beillesztése fordítási hibát okoz.
        \item \textbf{Hagyományos megoldás:} \texttt{\#ifndef LABEL}, \texttt{\#define LABEL}, \texttt{\#endif}.
        \item \textbf{Egyszerűsítés:} A fájl legelső sorába írt \texttt{\#pragma once}.
        \item \textbf{Előny:} Nem kell egyedi makróneveket kitalálni, rövidebb, tisztább a kód, a fordító optimalizálhatja.
    \end{itemize}

    \item \textbf{Elődeklaráció (Forward Declaration)}
    \begin{itemize}
        \item \textbf{Módszer:} A header fájlban nem \texttt{\#include "Osztaly.h"}-t használunk, hanem csak kiírjuk: \texttt{class Osztaly;}.
        \item \textbf{Feltétele:} Csak akkor működik, ha az adott headerben csak pointert (\texttt{Osztaly*}) vagy referenciát (\texttt{Osztaly\&}) használunk az adott típusból (nem példányosítjuk, nem érjük el a mezőit).
        \item \textbf{Előny:} 
        \begin{itemize}
            \item Drasztikusan csökken a fordítási idő (kevesebb fájlt kell feldolgozni).
            \item Megszünteti a körkörös hivatkozásokat (A include B, B include A).
        \end{itemize}
    \end{itemize}
\end{itemize}
