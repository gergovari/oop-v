\section{Ismertesse az osztályok kétoperandusú műveleteinek átdefiniálási lehetőségeit! Írjon példákat minden egyes lehetőséghez!}

\subsection{Áttekintés}
Kétoperandusú (bináris) operátorok (pl. \texttt{+}, \texttt{-}, \texttt{*}, \texttt{==}) esetén az operátornak egy bal oldali (LHS) és egy jobb oldali (RHS) operandusa van. C++-ban kétféleképpen definiálhatjuk ezeket.

\subsection{1. Lehetőség: Tagfüggvényként (Member Function)}
Az operátort az osztályon belül definiáljuk.

\begin{itemize}
    \item \textbf{Paraméterek száma:} Csak egy (a jobb oldali operandus).
    \item \textbf{Bal oldali operandus:} Implicit módon az aktuális objektum (\texttt{*this}).
    \item \textbf{Korlát:} A bal oldali operandusnak mindenképpen az adott osztály típusának kell lennie. Ezért például a \texttt{10 + obj} kifejezés nem valósítható meg így (mert a \texttt{int}-nek nincs ilyen tagfüggvénye).
    \item \textbf{Const-correctness:} Ha az operátor nem módosítja az objektumot (pl. összeadás), a függvényt \texttt{const}-ként kell jelölni.
\end{itemize}

\subsection{2. Lehetőség: Globális (Barát) függvényként (Global/Friend Function)}
Az operátort az osztályon kívül, szabad függvényként definiáljuk.

\begin{itemize}
    \item \textbf{Paraméterek száma:} Kettő (bal oldali és jobb oldali operandus).
    \item \textbf{Hozzáférési jog:} Ha a függvénynek el kell érnie a privát adattagokat, az osztályon belül \texttt{friend} kulcsszóval kell deklarálni.
    \item \textbf{Előny (Szimmetria):} Lehetővé teszi az implicit típuskonverziót a bal oldali operanduson is. (Pl. ha van \texttt{int} -> \texttt{Osztaly} konverzió, akkor a \texttt{10 + obj} működni fog).
    \item \textbf{Kötelező használat:} Ha a bal oldali operandus nem a mi osztályunk (pl. \texttt{std::ostream} a \texttt{<<} operátornál).
\end{itemize}

\subsection{Példakód}
Az alábbi példa a kivonást (\texttt{-}) tagfüggvényként, az összeadást (\texttt{+}) és a kiíratást (\texttt{<<}) pedig globális barát függvényként valósítja meg.

\begin{minted}[frame=lines, framesep=2mm, baselinestretch=1.2, fontsize=\footnotesize, linenos]{cpp}
#include <iostream>

class Pont {
private:
    int x, y;

public:
    Pont(int x = 0, int y = 0) : x(x), y(y) {}

    // --- 1. LEHETŐSÉG: Tagfüggvény (Kivonás) ---
    // Hívás: p1 - p2
    // Bal oldal: this, Jobb oldal: other
    Pont operator-(const Pont& other) const {
        // Új objektumot adunk vissza, az eredetit nem módosítjuk
        return Pont(this->x - other.x, this->y - other.y);
    }

    // --- 2. LEHETŐSÉG: Globális Barát Függvények ---
    
    // Összeadás (Barát deklaráció)
    // Hívás: p1 + p2 vagy p1 + 10 (konverzióval)
    friend Pont operator+(const Pont& lhs, const Pont& rhs);

    // Kiíratás (Barát deklaráció)
    // Kötelező globálisnak lennie, mert a bal oldal std::ostream
    friend std::ostream& operator<<(std::ostream& os, const Pont& p);
};

// Globális függvények definíciója:

Pont operator+(const Pont& lhs, const Pont& rhs) {
    // Itt nincs 'this', mindkét paraméter explicit
    return Pont(lhs.x + rhs.x, lhs.y + rhs.y);
}

std::ostream& operator<<(std::ostream& os, const Pont& p) {
    os << "(" << p.x << ", " << p.y << ")";
    return os;
}

int main() {
    Pont p1(10, 20);
    Pont p2(5, 5);

    // Tagfüggvény hívása
    Pont p3 = p1 - p2; 

    // Globális függvény hívása
    Pont p4 = p1 + p2; 

    // Globális operátor, láncolva
    std::cout << p3 << " es " << p4 << std::endl; 

    return 0;
}
\end{minted}